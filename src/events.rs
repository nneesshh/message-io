use std::time::Duration;

use crossbeam_channel as channel;

use crate::network::PollWaker;

/// As a shortcut, it returns the sender and receiver queue as a tuple.
///
/// Equivalent to:
/// ```
/// struct MyEvent; // or usually an enum
///
/// use message_io::events::EventReceiver;
///
/// let event_queue = EventReceiver::<MyEvent>::default();
/// let event_sender = event_queue.sender().clone();
/// ```
pub fn split<E: Send + 'static>() -> (EventSender<E>, EventReceiver<E>) {
    let event_queue = EventReceiver::default();
    let event_sender = event_queue.sender().clone();

    (event_sender, event_queue)
}

/// A generic and synchronized queue where the user can send and receive events.
/// See [`EventSender`] to see how send events.
pub struct EventReceiver<E> {
    event_sender: EventSender<E>, // Should be before receiver in order to drop first.
    receiver: channel::Receiver<E>,
}

impl<E> Default for EventReceiver<E>
where
    E: Send + 'static,
{
    /// Creates a new event queue for generic incoming events.
    fn default() -> Self {
        let (sender, receiver) = crossbeam_channel::unbounded();
        EventReceiver { event_sender: EventSender::new(sender), receiver }
    }
}

impl<E> EventReceiver<E>
where
    E: Send + 'static,
{
    /// Returns the internal sender reference to this queue.
    /// This reference can be safety cloned and shared to other threads
    /// in order to get several senders to the same queue.
    pub fn sender(&self) -> &EventSender<E> {
        &self.event_sender
    }

    /// Blocks the current thread until an event is received by this queue or timeout is exceeded.
    /// If timeout is reached a None is returned, otherwise the event is returned.
    pub fn receive_timeout(&self, timeout: Duration) -> Option<E> {
        channel::select! {
            recv(self.receiver) -> event => Some(event.unwrap()),
            default(timeout) => None
        }
    }

    /// Attempts to receive an event without blocking.
    /// Returns Some(E) if an event was received by this queue, otherwise returns None.
    pub fn try_receive(&self) -> Option<E> {
        if let Ok(event) = self.receiver.try_recv() {
            return Some(event);
        }
        None
    }
}

impl<E> Clone for EventReceiver<E>
where
    E: Send + 'static,
{
    fn clone(&self) -> Self {
        Self { event_sender: self.sender().clone(), receiver: self.receiver.clone() }
    }
}

/// Struct used to send events into a [`EventReceiver`].
/// This type can only be generated by the receiver `EventReceiver`.
pub struct EventSender<E> {
    sender: channel::Sender<E>,
}

impl<E> EventSender<E>
where
    E: Send + 'static,
{
    fn new(sender: channel::Sender<E>) -> EventSender<E> {
        EventSender { sender }
    }

    /// Send instantly an event to the event queue.
    pub fn post(&self, waker: &PollWaker, event: E) {
        self.sender.send(event).ok();
        waker.wake();
    }
}

impl<E> Clone for EventSender<E>
where
    E: Send + 'static,
{
    fn clone(&self) -> Self {
        EventSender::new(self.sender.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    lazy_static::lazy_static! {
        static ref ZERO_MS: Duration = Duration::from_millis(0);
    }

    #[test]
    fn drop_queue_before_sender() {
        let queue = EventReceiver::<()>::default();
        let sender = queue.sender().clone();
        drop(queue);
        drop(sender);
    }
}
